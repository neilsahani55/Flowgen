{% extends 'base_dashboard.html' %}
{% load static %}

{% block title %}SEO Error Checker{% endblock %}

{% block content %}
<div class="container">
    <header>
        <h1><i class="fas fa-search"></i> SEO Error Checker</h1>
        <p class="subtitle">Submit a URL to analyze and receive detailed SEO error reports with suggested fixes</p>
    </header>

    <section class="input-section">
        <div class="input-group">
            <input type="url" id="url-input" placeholder="Enter a URL to analyze (e.g., https://example.com)" required>
            <button id="submit-btn">
                <i class="fas fa-paper-plane"></i> Submit
            </button>
        </div>
        <div class="textarea-group">
            <textarea id="url-notes" placeholder="Add Page Content Here"></textarea>
        </div>
    </section>

    <div class="loading" id="loading">
        <div class="spinner"></div>
        <p>Analyzing URL for SEO errors. This may take a moment...</p>
    </div>

    <div class="error-message" id="error-message">
        <strong>Error:</strong> <span id="error-text"></span>
    </div>

    <section class="results-section" id="results-section">
        <div class="url-display" id="url-display">
            <strong>Analyzed URL:</strong> <span id="analyzed-url"></span>
        </div>

        <!-- Preview Tabs -->
        <div class="preview-tabs">
            <button class="preview-tab active" data-tab="page">
                <i class="fas fa-eye"></i> Page Preview
            </button>
            <button class="preview-tab" data-tab="code">
                <i class="fas fa-code"></i> Code Preview
            </button>
        </div>

        <!-- Page Preview Section -->
        <section class="page-preview preview-content active" id="page-preview">
            <div class="page-frame-wrap">
                <iframe id="page-preview-iframe" class="page-frame"
                    sandbox="allow-scripts allow-same-origin allow-forms" referrerpolicy="no-referrer"></iframe>
            </div>
        </section>

        <!-- Code Preview Section -->
        <section class="code-preview preview-content" id="code-preview">
            <div class="code-preview-header">
                <span><i class="fas fa-file-code"></i> HTML Source Code</span>
                <button id="refresh-code-btn" class="refresh-btn" title="Refresh code">
                    <i class="fas fa-sync-alt"></i>
                </button>
            </div>
            <div class="code-preview-body">
                <pre id="code-content"><code id="code-display">Loading HTML content...</code></pre>
            </div>
            <div class="code-loading" id="code-loading">
                <div class="spinner-small"></div>
                <p>Fetching HTML content...</p>
            </div>
        </section>

        <div class="summary" id="summary">
            <h2>SEO Error Analysis Results</h2>
            <div class="metrics-panel" id="metrics-panel">
                <div class="metric-card" id="metric-total-card"
                    title="Total errors detected. Higher totals indicate more SEO issues to address." role="button"
                    tabindex="0">
                    <div class="metric-header">
                        <div class="metric-value" id="metric-total-value">0</div>
                        <div class="metric-trend" id="metric-total-trend"><i class="fas fa-minus"></i></div>
                    </div>
                    <div class="metric-label">Total Errors</div>
                    <div class="metric-bar">
                        <div class="metric-bar-fill" id="metric-total-bar"
                            style="background-color: var(--danger-color);"></div>
                    </div>
                </div>
                <div class="metric-card" id="metric-spelling-card"
                    title="Spelling issues reduce credibility and can harm SEO through poor user experience."
                    role="button" tabindex="0">
                    <div class="metric-header">
                        <div class="metric-value" id="metric-spelling-value">0</div>
                        <div class="metric-trend" id="metric-spelling-trend"><i class="fas fa-minus"></i></div>
                    </div>
                    <div class="metric-label">Spelling Errors</div>
                    <div class="metric-bar">
                        <div class="metric-bar-fill" id="metric-spelling-bar"
                            style="background-color: var(--danger-color);"></div>
                    </div>
                </div>
                <div class="metric-card" id="metric-grammar-card"
                    title="Grammar issues affect clarity and can reduce engagement and rankings." role="button"
                    tabindex="0">
                    <div class="metric-header">
                        <div class="metric-value" id="metric-grammar-value">0</div>
                        <div class="metric-trend" id="metric-grammar-trend"><i class="fas fa-minus"></i></div>
                    </div>
                    <div class="metric-label">Grammar Issues</div>
                    <div class="metric-bar">
                        <div class="metric-bar-fill" id="metric-grammar-bar"
                            style="background-color: var(--warning-color);"></div>
                    </div>
                </div>
                <div class="metric-card" id="metric-content-card"
                    title="Content issues cover clarity, consistency and relevancy impacting SEO." role="button"
                    tabindex="0">
                    <div class="metric-header">
                        <div class="metric-value" id="metric-content-value">0</div>
                        <div class="metric-trend" id="metric-content-trend"><i class="fas fa-minus"></i></div>
                    </div>
                    <div class="metric-label">Content Issues</div>
                    <div class="metric-bar">
                        <div class="metric-bar-fill" id="metric-content-bar"
                            style="background-color: var(--secondary-color);"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="category-filter" id="category-filter">
            <button class="category-btn active" data-category="all">All Errors</button>
            <button class="category-btn" data-category="spelling">Spelling</button>
            <button class="category-btn" data-category="grammar">Grammar</button>
            <button class="category-btn" data-category="content">Content</button>
            <button class="category-btn" data-category="punctuation">Punctuation</button>
        </div>

        <div class="errors-container" id="errors-container">
            <!-- Error cards will be dynamically inserted here -->
        </div>
    </section>

    <div class="empty-state" id="empty-state">
        <i class="fas fa-file-alt"></i>
        <h3>No Results Yet</h3>
        <p>Submit a URL above to see SEO error analysis results</p>
    </div>

    <div class="no-results" id="no-results">
        <i class="fas fa-check-circle" style="color: #28a745; font-size: 3rem; margin-bottom: 15px;"></i>
        <h3>No Errors Found</h3>
        <p>Great job! The URL you submitted doesn't have any SEO errors.</p>
    </div>
</div>

<!-- Tooltip for error highlighting -->
<div class="error-tooltip" id="error-tooltip">
    <div class="tooltip-header">
        <strong>Error:</strong>
        <span class="tooltip-type"></span>
    </div>
    <div class="tooltip-body">
        <div class="tooltip-error"></div>
        <div class="tooltip-fix">
            <strong>Suggested Fix:</strong>
            <div class="tooltip-fix-content"></div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<style>
    /* Your SEO Error Checker CSS styles */
    :root {
        --primary-color: #4361ee;
        --secondary-color: #3f37c9;
        --success-color: #4cc9f0;
        --danger-color: #f72585;
        --warning-color: #f8961e;
        --light-color: #f8f9fa;
        --dark-color: #212529;
        --gray-color: #6c757d;
        --light-gray: #e9ecef;
        --border-radius: 8px;
        --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        --transition: all 0.3s ease;
    }

    /* Override base dashboard container styles */
    .main-content {
        margin-left: var(--sidebar-width);
        padding: 0 !important;
    }

    /* Container for SEO checker */
    .seo-container {
        padding: 1.5rem;
        max-width: 1400px;
        margin: 0 auto;
    }

    /* Adjust header styles */
    .seo-header {
        text-align: center;
        margin-bottom: 30px;
        padding: 20px;
        background: white;
        border-radius: var(--border-radius);
        box-shadow: var(--box-shadow);
    }

    .seo-header h1 {
        color: var(--primary-color);
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
    }

    .seo-header .subtitle {
        color: var(--gray-color);
        font-size: 1.1rem;
    }

    .input-section {
        background: white;
        padding: 25px;
        border-radius: var(--border-radius);
        box-shadow: var(--box-shadow);
        margin-bottom: 30px;
    }

    .input-group {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
    }

    .textarea-group {
        margin-top: 10px;
    }

    #url-input {
        flex: 1;
        padding: 15px;
        border: 2px solid var(--light-gray);
        border-radius: var(--border-radius);
        font-size: 1rem;
        transition: var(--transition);
    }

    #url-input:focus {
        outline: none;
        border-color: var(--primary-color);
    }

    #url-notes {
        width: 100%;
        min-height: 80px;
        padding: 12px 15px;
        border: 2px solid var(--light-gray);
        border-radius: var(--border-radius);
        font-size: 0.95rem;
        transition: var(--transition);
        resize: vertical;
    }

    #url-notes:focus {
        outline: none;
        border-color: var(--primary-color);
    }

    #submit-btn {
        background-color: var(--primary-color);
        color: white;
        border: none;
        border-radius: var(--border-radius);
        padding: 0 25px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: var(--transition);
        display: flex;
        align-items: center;
        gap: 8px;
    }

    #submit-btn:hover {
        background-color: var(--secondary-color);
    }

    #submit-btn:disabled {
        background-color: var(--gray-color);
        cursor: not-allowed;
    }

    .note {
        color: var(--gray-color);
        font-size: 0.9rem;
        margin-top: 10px;
    }

    .loading {
        display: none;
        text-align: center;
        margin: 30px 0;
    }

    .spinner {
        border: 4px solid rgba(0, 0, 0, 0.1);
        border-radius: 50%;
        border-top: 4px solid var(--primary-color);
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 0 auto 15px;
    }

    .spinner-small {
        border: 3px solid rgba(0, 0, 0, 0.1);
        border-radius: 50%;
        border-top: 3px solid var(--primary-color);
        width: 30px;
        height: 30px;
        animation: spin 1s linear infinite;
        margin: 0 auto 10px;
    }

    @keyframes spin {
        0% {
            transform: rotate(0deg);
        }

        100% {
            transform: rotate(360deg);
        }
    }

    .results-section {
        display: none;
    }

    .summary {
        background: white;
        padding: 20px;
        border-radius: var(--border-radius);
        box-shadow: var(--box-shadow);
        margin-bottom: 20px;
    }

    .summary h2 {
        color: var(--primary-color);
        margin-bottom: 20px;
    }

    .errors-container {
        display: grid;
        grid-template-columns: 1fr;
        gap: 20px;
    }

    .error-card {
        background: white;
        border-radius: var(--border-radius);
        box-shadow: var(--box-shadow);
        overflow: hidden;
        transition: var(--transition);
    }

    .error-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
    }

    .error-header {
        background-color: #fff3cd;
        color: #856404;
        padding: 15px 20px;
        border-bottom: 1px solid #ffeaa7;
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
    }

    .error-type {
        font-weight: bold;
        font-size: 1.1rem;
    }

    .error-id {
        background-color: var(--warning-color);
        color: white;
        font-weight: bold;
        padding: 5px 10px;
        border-radius: 20px;
        font-size: 0.8rem;
    }

    .error-body {
        padding: 0;
    }

    .dropdown-toggle {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        color: var(--primary-color);
        user-select: none;
        width: 100%;
    }

    .toggle-icon {
        transition: transform 0.2s ease;
    }

    .toggle-icon.rotate {
        transform: rotate(90deg);
    }

    .error-section {
        margin-bottom: 20px;
    }

    .error-section:last-child {
        margin-bottom: 0;
    }

    .section-title {
        font-weight: 600;
        margin-bottom: 8px;
        color: var(--primary-color);
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 0 15px;
    }

    .error-text,
    .location-text,
    .fix-text {
        padding: 15px;
        border-radius: var(--border-radius);
        white-space: pre-wrap;
        overflow-x: auto;
        margin: 0 15px;
    }

    .error-text {
        background-color: #fff3cd;
        border-left: 4px solid var(--warning-color);
    }

    .location-text {
        background-color: #f8f9fa;
        border-left: 4px solid var(--gray-color);
        font-family: monospace;
    }

    .fix-text {
        background-color: #d4edda;
        border-left: 4px solid #28a745;
    }

    .code-block {
        background-color: #2b2b2b;
        color: #f8f8f2;
        padding: 15px;
        border-radius: 5px;
        margin-top: 10px;
        font-family: 'Courier New', monospace;
        overflow-x: auto;
    }

    .fix-options {
        margin-top: 10px;
    }

    .fix-option {
        margin-bottom: 10px;
        padding-left: 15px;
        position: relative;
    }

    .fix-option:before {
        content: "\2713";
        position: absolute;
        left: 0;
        color: #28a745;
        font-weight: bold;
    }

    .empty-state {
        text-align: center;
        padding: 60px 20px;
        color: var(--gray-color);
    }

    .empty-state i {
        font-size: 3rem;
        margin-bottom: 15px;
        color: var(--light-gray);
    }

    .no-results {
        text-align: center;
        padding: 40px 20px;
        display: none;
    }

    /* Preview Tabs Styles */
    .preview-tabs {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
        background: white;
        padding: 15px 15px 0 15px;
        border-radius: var(--border-radius) var(--border-radius) 0 0;
        box-shadow: var(--box-shadow);
    }

    .preview-tab {
        padding: 12px 24px;
        background: transparent;
        border: none;
        border-bottom: 3px solid transparent;
        cursor: pointer;
        font-size: 1rem;
        font-weight: 600;
        color: var(--gray-color);
        transition: var(--transition);
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .preview-tab:hover {
        color: var(--primary-color);
        background: rgba(67, 97, 238, 0.05);
    }

    .preview-tab.active {
        color: var(--primary-color);
        border-bottom-color: var(--primary-color);
    }

    .preview-content {
        display: none;
        background: white;
        border-radius: 0 0 var(--border-radius) var(--border-radius);
        box-shadow: var(--box-shadow);
        margin-bottom: 20px;
        border: 1px solid var(--light-gray);
        border-top: none;
    }

    .preview-content.active {
        display: block;
    }

    /* Page Preview Styles */
    .page-preview {
        border-radius: 0 0 var(--border-radius) var(--border-radius);
    }

    .page-frame-wrap {
        height: 500px;
    }

    .page-frame {
        width: 100%;
        height: 100%;
        border: 0;
        background: #fff;
    }

    /* Code Preview Styles */
    .code-preview {
        position: relative;
    }

    .code-preview-header {
        padding: 12px 15px;
        border-bottom: 1px solid var(--light-gray);
        background: #f8f9fa;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.95rem;
        color: var(--gray-color);
    }

    .refresh-btn {
        background: var(--primary-color);
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 0.9rem;
        transition: var(--transition);
        display: flex;
        align-items: center;
        gap: 5px;
    }

    .refresh-btn:hover {
        background: var(--secondary-color);
    }

    .code-preview-body {
        height: 500px;
        overflow: auto;
        background: #1e1e1e;
        position: relative;
    }

    #code-content {
        margin: 0;
        padding: 20px;
        font-family: 'Courier New', Consolas, monospace;
        font-size: 13px;
        line-height: 1.6;
        color: #d4d4d4;
        white-space: pre;
        tab-size: 4;
    }

    #code-display {
        display: block;
        color: #d4d4d4;
    }

    .code-loading {
        display: none;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        color: var(--gray-color);
    }

    .code-loading.active {
        display: block;
    }

    /* Error Highlighting in Code */
    .code-error-highlight {
        background-color: rgba(247, 37, 133, 0.25);
        border-bottom: 2px solid var(--danger-color);
        cursor: pointer;
        position: relative;
        padding: 2px 0;
        margin: 0 2px;
        border-radius: 2px;
        transition: all 0.2s ease;
        display: inline;
    }

    .code-error-highlight:hover {
        background-color: rgba(247, 37, 133, 0.45);
        padding: 3px 4px;
        margin: 0;
    }

    .code-error-highlight.spelling {
        background-color: rgba(247, 37, 133, 0.25);
        border-bottom-color: var(--danger-color);
    }

    .code-error-highlight.spelling:hover {
        background-color: rgba(247, 37, 133, 0.45);
    }

    .code-error-highlight.grammar {
        background-color: rgba(248, 150, 30, 0.25);
        border-bottom-color: var(--warning-color);
    }

    .code-error-highlight.grammar:hover {
        background-color: rgba(248, 150, 30, 0.45);
    }

    .code-error-highlight.content {
        background-color: rgba(63, 55, 201, 0.25);
        border-bottom-color: var(--secondary-color);
    }

    .code-error-highlight.content:hover {
        background-color: rgba(63, 55, 201, 0.45);
    }

    /* Error Tooltip */
    .error-tooltip {
        position: fixed;
        display: none;
        background: white;
        border: 2px solid var(--primary-color);
        border-radius: var(--border-radius);
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        padding: 0;
        max-width: 450px;
        min-width: 300px;
        z-index: 999999;
        pointer-events: none;
        animation: tooltipFadeIn 0.15s ease;
    }

    @keyframes tooltipFadeIn {
        from {
            opacity: 0;
            transform: translateY(-5px) scale(0.95);
        }

        to {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
    }

    .error-tooltip.show {
        display: block;
        pointer-events: auto;
    }

    .tooltip-header {
        background: var(--primary-color);
        color: white;
        padding: 10px 15px;
        font-weight: 600;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-radius: var(--border-radius) var(--border-radius) 0 0;
    }

    .tooltip-type {
        background: rgba(255, 255, 255, 0.2);
        padding: 3px 10px;
        border-radius: 12px;
        font-size: 0.85rem;
        text-transform: uppercase;
    }

    .tooltip-body {
        padding: 15px;
        max-height: 350px;
        overflow-y: auto;
        font-size: 0.95rem;
        line-height: 1.5;
    }

    .tooltip-error {
        margin-bottom: 12px;
        padding: 12px;
        background: #fff3cd;
        border-left: 4px solid var(--warning-color);
        border-radius: 4px;
        font-size: 0.9rem;
        color: #856404;
        word-wrap: break-word;
    }

    .tooltip-fix {
        padding: 12px;
        background: #d4edda;
        border-left: 4px solid #28a745;
        border-radius: 4px;
        font-size: 0.9rem;
    }

    .tooltip-fix strong {
        display: block;
        margin-bottom: 8px;
        color: #155724;
        font-weight: 600;
    }

    .tooltip-fix-content {
        color: #155724;
        line-height: 1.6;
        word-wrap: break-word;
    }

    .tooltip-fix-content .fix-option {
        margin-bottom: 6px;
        padding-left: 0;
    }

    .tooltip-fix-content .fix-option:before {
        content: "? ";
        color: #28a745;
        font-weight: bold;
        margin-right: 4px;
    }

    .error-details {
        display: none;
        padding: 20px 15px;
        background-color: #f9f9f9;
    }

    .error-two-col {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-bottom: 20px;
    }

    .error-col-content {
        max-height: 220px;
        overflow: auto;
        background: #fff;
        border-radius: var(--border-radius);
        border: 1px solid var(--light-gray);
    }

    .location-block {
        margin-top: 20px;
    }

    header {
        text-align: center;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding: 40px 0;
    }

    header h1 {
        font-size: 32px;
        font-weight: 700;
        margin-bottom: 10px;
    }

    header .subtitle {
        font-size: 18px;
        color: #666;
        max-width: 600px;
    }

    .location-toggle {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: #f8f9fa;
        padding: 12px 15px;
        border-radius: var(--border-radius);
        cursor: pointer;
        border: 1px solid var(--light-gray);
        margin: 0 15px;
    }

    .location-content {
        display: none;
        margin-top: 15px;
        max-height: 220px;
        overflow: auto;
        padding: 0 15px;
    }

    .metrics-panel {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 16px;
        width: 100%;
    }

    .metric-card {
        background: #ffffff;
        border: 1px solid var(--light-gray);
        border-radius: var(--border-radius);
        padding: 16px;
        box-shadow: var(--box-shadow);
        transition: var(--transition);
        cursor: pointer;
    }

    .metric-card:hover {
        transform: translateY(-3px);
        box-shadow: 0 6px 14px rgba(0, 0, 0, 0.1);
    }

    .metric-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 8px;
    }

    .metric-value {
        font-size: clamp(1.5rem, 4vw, 2.2rem);
        font-weight: 700;
        color: var(--primary-color);
    }

    .metric-label {
        color: var(--gray-color);
        font-weight: 600;
        margin-bottom: 10px;
    }

    .metric-trend {
        font-size: 1rem;
    }

    .metric-bar {
        height: 8px;
        background: var(--light-gray);
        border-radius: 999px;
        overflow: hidden;
        margin-bottom: 12px;
    }

    .metric-bar-fill {
        height: 100%;
        width: 0%;
        transition: width 0.4s ease;
    }

    .error-card.highlight {
        outline: 2px solid var(--primary-color);
    }

    .error-card.dim {
        opacity: 0.45;
    }

    .error-message {
        background-color: #f8d7da;
        color: #721c24;
        padding: 15px;
        border-radius: var(--border-radius);
        margin: 20px 0;
        display: none;
        border-left: 4px solid #f5c6cb;
    }

    .category-filter {
        display: none;
        gap: 10px;
        margin-bottom: 20px;
        flex-wrap: wrap;
    }

    .category-btn {
        padding: 8px 16px;
        background: white;
        border: 1px solid var(--light-gray);
        border-radius: 20px;
        cursor: pointer;
        transition: var(--transition);
    }

    .category-btn:hover {
        background: var(--light-gray);
    }

    .category-btn.active {
        background: var(--primary-color);
        color: white;
        border-color: var(--primary-color);
    }

    .url-display {
        background-color: #f8f9fa;
        padding: 12px 15px;
        border-radius: var(--border-radius);
        margin-bottom: 20px;
        border-left: 4px solid var(--primary-color);
        font-size: 0.9rem;
    }

    .location-item {
        margin-bottom: 8px;
        padding-left: 15px;
        position: relative;
    }

    .location-item:before {
        content: "\2022";
        position: absolute;
        left: 0;
        color: var(--gray-color);
    }

    @media (max-width: 768px) {
        .metrics-panel {
            grid-template-columns: 1fr;
        }

        .error-two-col {
            grid-template-columns: 1fr;
        }

        .input-group {
            flex-direction: column;
        }

        #submit-btn {
            padding: 15px;
            justify-content: center;
        }

        .main-content {
            margin-left: 70px;
        }

        .seo-container {
            padding: 1rem;
        }

        .error-tooltip {
            max-width: 90vw;
        }

        .preview-tabs {
            flex-wrap: wrap;
        }
    }

    @media (min-width: 1024px) {
        .metrics-panel {
            grid-template-columns: repeat(4, 1fr);
        }
    }
</style>

<script>
    document.addEventListener('DOMContentLoaded', function () {
        const urlInput = document.getElementById('url-input');
        const notesInput = document.getElementById('url-notes');
        const submitBtn = document.getElementById('submit-btn');
        const loading = document.getElementById('loading');
        const resultsSection = document.getElementById('results-section');
        const emptyState = document.getElementById('empty-state');
        const noResults = document.getElementById('no-results');
        const errorMessage = document.getElementById('error-message');
        const errorText = document.getElementById('error-text');
        const errorsContainer = document.getElementById('errors-container');
        const metricTotalValue = document.getElementById('metric-total-value');
        const metricSpellingValue = document.getElementById('metric-spelling-value');
        const metricGrammarValue = document.getElementById('metric-grammar-value');
        const metricContentValue = document.getElementById('metric-content-value');
        const metricTotalBar = document.getElementById('metric-total-bar');
        const metricSpellingBar = document.getElementById('metric-spelling-bar');
        const metricGrammarBar = document.getElementById('metric-grammar-bar');
        const metricContentBar = document.getElementById('metric-content-bar');
        const pagePreview = document.getElementById('page-preview');
        const pagePreviewIframe = document.getElementById('page-preview-iframe');
        const codePreview = document.getElementById('code-preview');
        const codeDisplay = document.getElementById('code-display');
        const codeLoading = document.getElementById('code-loading');
        const refreshCodeBtn = document.getElementById('refresh-code-btn');
        const errorTooltip = document.getElementById('error-tooltip');
        const metricTotalTrend = document.getElementById('metric-total-trend');
        const metricSpellingTrend = document.getElementById('metric-spelling-trend');
        const metricGrammarTrend = document.getElementById('metric-grammar-trend');
        const metricContentTrend = document.getElementById('metric-content-trend');
        const categoryFilter = document.getElementById('category-filter');
        const urlDisplay = document.getElementById('url-display');
        const analyzedUrlSpan = document.getElementById('analyzed-url');
        let lastMetrics = { total: 0, spelling: 0, grammar: 0, content: 0 };

        const webhookUrl = '';

        // Store current errors for filtering and highlighting
        let currentErrors = [];
        let currentUrl = '';
        let htmlContent = '';

        // Preview tab switching
        document.querySelectorAll('.preview-tab').forEach(tab => {
            tab.addEventListener('click', function () {
                const targetTab = this.dataset.tab;

                // Update active tab
                document.querySelectorAll('.preview-tab').forEach(t => t.classList.remove('active'));
                this.classList.add('active');

                // Update active content
                document.querySelectorAll('.preview-content').forEach(c => c.classList.remove('active'));
                if (targetTab === 'page') {
                    pagePreview.classList.add('active');
                } else if (targetTab === 'code') {
                    codePreview.classList.add('active');
                    if (!htmlContent) {
                        fetchAndDisplayCode();
                    }
                }
            });
        });

        // Refresh code button
        refreshCodeBtn.addEventListener('click', function () {
            fetchAndDisplayCode();
        });

        // Event listener for submit button
        submitBtn.addEventListener('click', submitUrl);

        // Also allow form submission with Enter key
        urlInput.addEventListener('keypress', function (e) {
            if (e.key === 'Enter') {
                submitUrl();
            }
        });

        // Category filter event listeners
        categoryFilter.addEventListener('click', function (e) {
            if (e.target.classList.contains('category-btn')) {
                // Update active button
                document.querySelectorAll('.category-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                e.target.classList.add('active');

                // Filter errors
                const category = e.target.dataset.category;
                filterErrors(category);
            }
        });

        function submitUrl() {
            const url = urlInput.value.trim();
            const notes = notesInput.value.trim();

            if (!url) {
                showError('Please enter a valid URL');
                return;
            }

            try {
                new URL(url);
            } catch (e) {
                showError('Please enter a valid URL (e.g., https://example.com)');
                return;
            }

            currentUrl = url;
            htmlContent = '';
            analyzedUrlSpan.textContent = url;
            pagePreviewIframe.src = url;

            loading.style.display = 'block';
            emptyState.style.display = 'none';
            resultsSection.style.display = 'none';
            noResults.style.display = 'none';
            errorMessage.style.display = 'none';
            submitBtn.disabled = true;

            const requestData = {
                url: url,
                notes: notes,
                timestamp: new Date().toISOString()
            };

            fetch(webhookUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestData)
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.text();
                })
                .then(text => {
                    const parsed = parseMaybeJson(text);
                    const normalized = normalizeResponse(parsed);
                    displayResults(normalized);
                })
                .catch(error => {
                    console.error('Error:', error);
                    showError('Failed to analyze URL. Please check the URL and try again.');
                })
                .finally(() => {
                    loading.style.display = 'none';
                    submitBtn.disabled = false;
                });
        }

        function parseMaybeJson(value) {
            if (typeof value === 'string') {
                try { return JSON.parse(value); } catch (_) { return value; }
            }
            return value;
        }

        function normalizeResponse(data) {
            if (Array.isArray(data)) return data;
            if (!data) return [];
            if (typeof data === 'object') {
                if (Array.isArray(data.data)) return data.data;
                if (Array.isArray(data.body)) return data.body;
                if (Array.isArray(data.json)) return data.json;
                if (typeof data.body === 'string') {
                    const b = parseMaybeJson(data.body);
                    if (Array.isArray(b)) return b;
                }
                const keys = Object.keys(data);
                const grouped = {};
                keys.forEach(k => {
                    const m = k.match(/^(.*?)(?:_error|_location|_suggested_fixes)$/);
                    if (m) {
                        const p = m[1];
                        grouped[p] = grouped[p] || {};
                        grouped[p][k] = data[k];
                    }
                });
                const arr = Object.values(grouped);
                if (arr.length) return arr;
            }
            if (typeof data === 'string') {
                const j = parseMaybeJson(data);
                if (Array.isArray(j)) return j;
            }
            return [];
        }

        function groupItemEntries(obj) {
            if (!obj || typeof obj !== 'object') return [];
            const grouped = {};
            Object.keys(obj).forEach(k => {
                const m = k.match(/^(.*?)(?:_error|_location|_suggested_fixes)$/);
                if (m) {
                    const p = m[1];
                    grouped[p] = grouped[p] || {};
                    grouped[p][k] = obj[k];
                }
            });
            return Object.values(grouped);
        }

        function displayResults(data) {
            // Check if data is valid
            if (!data) {
                showError('No response received from the server');
                return;
            }

            // Check if it's an array
            if (!Array.isArray(data)) {
                const normalized = normalizeResponse(data);
                if (!Array.isArray(normalized)) {
                    showError('Invalid response format from server');
                    return;
                }
                data = normalized;
            }

            // Check if array is empty
            if (data.length === 0) {
                noResults.style.display = 'block';
                emptyState.style.display = 'none';
                resultsSection.style.display = 'none';
                categoryFilter.style.display = 'none';
                urlDisplay.style.display = 'block';
                return;
            }

            // Store errors for filtering
            currentErrors = data;

            // Clear previous results
            errorsContainer.innerHTML = '';

            // Process the data
            let renderedCount = 0;
            let spellingCount = 0;
            let grammarCount = 0;
            let contentCount = 0;

            data.forEach((item, index) => {
                const groups = groupItemEntries(item);
                const itemsToRender = groups.length ? groups : [item];
                itemsToRender.forEach((it, subIndex) => {
                    const errorKey = Object.keys(it).find(key => key.includes('_error'));
                    const locationKey = Object.keys(it).find(key => key.includes('_location'));
                    const fixKey = Object.keys(it).find(key => key.includes('_suggested_fixes'));
                    if (!errorKey) return;
                    const error = it[errorKey] || '';
                    const location = it[locationKey] || '';
                    const fixes = it[fixKey] || '';
                    const errorLower = String(error).toLowerCase();
                    let type = 'content';
                    if (errorLower.includes('spelling')) {
                        type = 'spelling';
                        spellingCount++;
                    } else if (errorLower.includes('punctuation') || errorLower.includes('grammar') || errorLower.includes('grammatical') || errorLower.includes('awkward')) {
                        type = 'grammar';
                        grammarCount++;
                    } else {
                        contentCount++;
                    }

                    const errorCard = document.createElement('div');
                    errorCard.className = 'error-card';
                    errorCard.dataset.type = type;
                    errorCard.dataset.errorIndex = renderedCount;
                    errorCard.innerHTML = `
                        <div class="error-header error-toggle" aria-expanded="false">
                            <div class="dropdown-toggle">
                                <i class="fas fa-chevron-right toggle-icon"></i>
                                <div style="flex: 1;">
                                    <div class="error-type">Error #${renderedCount + 1}</div>
                                    <div style="font-size: 0.9rem; margin-top: 4px;">${getErrorSummary(error)}</div>
                                </div>
                            </div>
                            <span class="error-id">${type.toUpperCase()}</span>
                        </div>
                        <div class="error-body">
                            <div class="error-details">
                                <div class="error-two-col">
                                    <div class="error-section">
                                        <div class="section-title">
                                            <i class="fas fa-exclamation-circle"></i>
                                            <span>Error Description</span>
                                        </div>
                                        <div class="error-col-content">
                                            <div class="error-text">${escapeHtml(error)}</div>
                                        </div>
                                    </div>
                                    <div class="error-section">
                                        <div class="section-title">
                                            <i class="fas fa-lightbulb"></i>
                                            <span>Suggested Fixes</span>
                                        </div>
                                        <div class="error-col-content">
                                            <div class="fix-text">${fixes ? formatFixes(fixes) : 'No fixes suggested'}</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="location-block">
                                    <div class="location-toggle" aria-expanded="false">
                                        <span><i class="fas fa-code"></i> Location in Code</span>
                                        <i class="fas fa-chevron-right toggle-icon"></i>
                                    </div>
                                    <div class="location-content">
                                        <div class="location-text">${location ? formatLocationText(location) : 'Not provided'}</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                    errorsContainer.appendChild(errorCard);
                    renderedCount++;
                });
            });

            // Update summary
            const totalErrors = renderedCount;
            updateMetrics(totalErrors, spellingCount, grammarCount, contentCount);

            // Show results section
            emptyState.style.display = 'none';
            noResults.style.display = 'none';
            errorMessage.style.display = 'none';
            resultsSection.style.display = 'block';
            urlDisplay.style.display = 'block';

            // Hide category filter (no classification)
            categoryFilter.style.display = 'none';

            // Attach event listeners to new error cards
            attachErrorDropdowns();
        }

        function updateMetrics(total, spelling, grammar, content) {
            metricTotalValue.textContent = String(total);
            metricSpellingValue.textContent = String(spelling);
            metricGrammarValue.textContent = String(grammar);
            metricContentValue.textContent = String(content);

            const pct = (n, d) => d > 0 ? Math.max(0, Math.min(100, Math.round((n / d) * 100))) : 0;
            const pTotal = Math.min(100, total * 5);
            const pSpelling = pct(spelling, total);
            const pGrammar = pct(grammar, total);
            const pContent = pct(content, total);

            metricTotalBar.style.width = pTotal + '%';
            metricSpellingBar.style.width = pSpelling + '%';
            metricGrammarBar.style.width = pGrammar + '%';
            metricContentBar.style.width = pContent + '%';

            setTrend(metricTotalTrend, lastMetrics.total, total);
            setTrend(metricSpellingTrend, lastMetrics.spelling, spelling);
            setTrend(metricGrammarTrend, lastMetrics.grammar, grammar);
            setTrend(metricContentTrend, lastMetrics.content, content);
            lastMetrics = { total, spelling, grammar, content };
        }

        function setTrend(el, prev, curr) {
            const up = '<i class="fas fa-arrow-up" style="color: var(--danger-color);"></i>';
            const down = '<i class="fas fa-arrow-down" style="color: #28a745;"></i>';
            const flat = '<i class="fas fa-minus" style="color: var(--gray-color);"></i>';
            el.innerHTML = curr > prev ? up : curr < prev ? down : flat;
        }

        function attachMetricInteractions() {
            const map = {
                spelling: document.getElementById('metric-spelling-card'),
                grammar: document.getElementById('metric-grammar-card'),
                content: document.getElementById('metric-content-card'),
                total: document.getElementById('metric-total-card')
            };
            Object.keys(map).forEach(key => {
                const el = map[key];
                el.addEventListener('click', () => highlightType(key));
                el.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        highlightType(key);
                    }
                });
            });
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') clearHighlight();
            });
        }

        function attachErrorDropdowns() {
            // Error header toggle
            document.querySelectorAll('.error-header.error-toggle').forEach(toggle => {
                toggle.addEventListener('click', function (e) {
                    if (e.target.closest('.error-id')) return;

                    const card = this.closest('.error-card');
                    const details = card.querySelector('.error-details');
                    const icon = this.querySelector('.toggle-icon');
                    const expanded = details.style.display === 'block';

                    details.style.display = expanded ? 'none' : 'block';

                    if (icon) icon.classList.toggle('rotate', !expanded);

                    this.setAttribute('aria-expanded', (!expanded).toString());
                });
            });

            // Location toggle
            document.querySelectorAll('.location-toggle').forEach(toggle => {
                toggle.addEventListener('click', function () {
                    const content = this.nextElementSibling;
                    const icon = this.querySelector('.toggle-icon');
                    const expanded = content.style.display === 'block';

                    content.style.display = expanded ? 'none' : 'block';
                    if (icon) icon.classList.toggle('rotate', !expanded);
                    this.setAttribute('aria-expanded', (!expanded).toString());
                });
            });
        }

        function highlightType(type) {
            const cards = Array.from(document.querySelectorAll('.error-card'));
            if (type === 'total') {
                clearHighlight();
                return;
            }
            cards.forEach(c => {
                const match = c.dataset.type === type;
                c.classList.toggle('highlight', match);
                c.classList.toggle('dim', !match);
            });
        }

        function clearHighlight() {
            const cards = Array.from(document.querySelectorAll('.error-card'));
            cards.forEach(c => {
                c.classList.remove('highlight');
                c.classList.remove('dim');
            });
        }

        // Fetch and display HTML code with error highlighting
        async function fetchAndDisplayCode() {
            if (!currentUrl) return;

            codeLoading.classList.add('active');
            codeDisplay.textContent = 'Fetching HTML content...';

            // Try multiple methods sequentially for better success rate
            const methods = [
                { name: 'AllOrigins', func: fetchViaProxy1 },
                { name: 'API AllOrigins', func: fetchViaProxy2 },
                { name: 'CorsProxy', func: fetchViaProxy3 },
                { name: 'Cors.sh', func: fetchViaProxy4 },
                { name: 'ThingProxy', func: fetchViaProxy5 },
                { name: 'Iframe', func: fetchViaIframe }
            ];

            let lastError = null;

            // Try each method sequentially
            for (const method of methods) {
                try {
                    console.log(`Trying ${method.name}...`);
                    const html = await method.func();

                    if (html && html.length > 50) {
                        console.log(`${method.name} succeeded!`);
                        htmlContent = html;
                        codeDisplay.textContent = 'Processing HTML...';

                        // Use setTimeout to prevent UI blocking
                        setTimeout(() => {
                            displayCodeWithHighlights(html);
                            codeLoading.classList.remove('active');
                        }, 10);
                        return; // Success!
                    }
                } catch (error) {
                    console.warn(`${method.name} failed:`, error.message);
                    lastError = error;
                    // Continue to next method
                }
            }

            // All methods failed
            console.error('All fetch methods failed:', lastError);
            codeLoading.classList.remove('active');
            codeDisplay.innerHTML = `
                <div style="color: #f8961e; padding: 20px; text-align: center;">
                    <i class="fas fa-exclamation-triangle" style="font-size: 2rem; margin-bottom: 10px;"></i>
                    <h3>Unable to Load HTML Content</h3>
                    <p style="margin-top: 10px; color: #999;">Could not fetch the page source code after trying multiple methods.</p>
                    <p style="margin-top: 5px; color: #999;">The website may have strict CORS policies or security restrictions.</p>
                    <p style="margin-top: 10px; color: #666; font-size: 0.9rem;">You can still view the page preview and error analysis above.</p>
                </div>
            `;
        }

        // Method 1: AllOrigins raw (most reliable)
        async function fetchViaProxy1() {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 10000);

            try {
                const proxyUrl = 'https://api.allorigins.win/raw?url=';
                const response = await fetch(proxyUrl + encodeURIComponent(currentUrl), {
                    signal: controller.signal
                });
                clearTimeout(timeout);

                if (!response.ok) throw new Error('HTTP ' + response.status);
                const text = await response.text();
                if (!text || text.length < 50) throw new Error('Invalid response');
                return text;
            } catch (error) {
                clearTimeout(timeout);
                throw error;
            }
        }

        // Method 2: AllOrigins with GET endpoint
        async function fetchViaProxy2() {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 10000);

            try {
                const proxyUrl = 'https://api.allorigins.win/get?url=';
                const response = await fetch(proxyUrl + encodeURIComponent(currentUrl), {
                    signal: controller.signal
                });
                clearTimeout(timeout);

                if (!response.ok) throw new Error('HTTP ' + response.status);
                const data = await response.json();
                const text = data.contents;
                if (!text || text.length < 50) throw new Error('Invalid response');
                return text;
            } catch (error) {
                clearTimeout(timeout);
                throw error;
            }
        }

        // Method 3: CorsProxy.io
        async function fetchViaProxy3() {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 10000);

            try {
                const proxyUrl = 'https://corsproxy.io/?';
                const response = await fetch(proxyUrl + encodeURIComponent(currentUrl), {
                    signal: controller.signal
                });
                clearTimeout(timeout);

                if (!response.ok) throw new Error('HTTP ' + response.status);
                const text = await response.text();
                if (!text || text.length < 50) throw new Error('Invalid response');
                return text;
            } catch (error) {
                clearTimeout(timeout);
                throw error;
            }
        }

        // Method 4: Cors.sh
        async function fetchViaProxy4() {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 10000);

            try {
                const proxyUrl = 'https://cors.sh/';
                const response = await fetch(proxyUrl + currentUrl, {
                    signal: controller.signal,
                    headers: {
                        'x-requested-with': 'XMLHttpRequest'
                    }
                });
                clearTimeout(timeout);

                if (!response.ok) throw new Error('HTTP ' + response.status);
                const text = await response.text();
                if (!text || text.length < 50) throw new Error('Invalid response');
                return text;
            } catch (error) {
                clearTimeout(timeout);
                throw error;
            }
        }

        // Method 5: ThingProxy
        async function fetchViaProxy5() {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 10000);

            try {
                const proxyUrl = 'https://thingproxy.freeboard.io/fetch/';
                const response = await fetch(proxyUrl + currentUrl, {
                    signal: controller.signal
                });
                clearTimeout(timeout);

                if (!response.ok) throw new Error('HTTP ' + response.status);
                const text = await response.text();
                if (!text || text.length < 50) throw new Error('Invalid response');
                return text;
            } catch (error) {
                clearTimeout(timeout);
                throw error;
            }
        }

        // Method 6: Try to read from iframe (works for same-origin)
        async function fetchViaIframe() {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    try {
                        const iframeDoc = pagePreviewIframe.contentDocument || pagePreviewIframe.contentWindow.document;
                        if (iframeDoc && iframeDoc.documentElement) {
                            const html = iframeDoc.documentElement.outerHTML;
                            if (html && html.length > 50) {
                                resolve(html);
                            } else {
                                reject(new Error('Iframe content unavailable'));
                            }
                        } else {
                            reject(new Error('Cannot access iframe'));
                        }
                    } catch (error) {
                        reject(error);
                    }
                }, 3000); // Give iframe more time to load
            });
        }

        function displayCodeWithHighlights(html) {
            // Escape HTML for display
            let displayHtml = escapeHtml(html);

            // Limit HTML size for performance
            const MAX_HTML_LENGTH = 500000; // 500KB limit
            if (displayHtml.length > MAX_HTML_LENGTH) {
                displayHtml = displayHtml.substring(0, MAX_HTML_LENGTH) + '\n\n... [Content truncated for performance]';
            }

            // Create a map of text content to errors (optimized)
            const errorMap = new Map();
            let errorIndex = 0;

            currentErrors.forEach((item) => {
                const groups = groupItemEntries(item);
                const itemsToRender = groups.length ? groups : [item];

                itemsToRender.forEach((it) => {
                    const errorKey = Object.keys(it).find(key => key.includes('_error'));
                    const locationKey = Object.keys(it).find(key => key.includes('_location'));
                    const fixKey = Object.keys(it).find(key => key.includes('_suggested_fixes'));

                    if (!errorKey) return;

                    const error = it[errorKey] || '';
                    const location = it[locationKey] || '';
                    const fixes = it[fixKey] || '';

                    // Determine error type
                    const errorLower = String(error).toLowerCase();
                    let type = 'content';
                    if (errorLower.includes('spelling')) {
                        type = 'spelling';
                    } else if (errorLower.includes('punctuation') || errorLower.includes('grammar') || errorLower.includes('grammatical') || errorLower.includes('awkward')) {
                        type = 'grammar';
                    }

                    // Extract text to highlight from location
                    const textToHighlight = extractTextFromLocation(location, html);

                    if (textToHighlight && textToHighlight.length > 2 && textToHighlight.length < 100) {
                        const key = textToHighlight.toLowerCase();
                        if (!errorMap.has(key)) {
                            errorMap.set(key, {
                                text: textToHighlight,
                                error: error,
                                fixes: fixes,
                                type: type,
                                index: errorIndex++
                            });
                        }
                    }
                });
            });

            // Convert map to array and sort by length (longest first)
            const errorArray = Array.from(errorMap.values()).sort((a, b) => b.text.length - a.text.length);

            // Limit number of highlights for performance
            const MAX_HIGHLIGHTS = 50;
            const highlightsToApply = errorArray.slice(0, MAX_HIGHLIGHTS);

            // Apply highlights using a more efficient method
            if (highlightsToApply.length > 0) {
                // Build a single regex for all patterns
                const patterns = highlightsToApply.map(errorInfo => {
                    const escapedText = escapeHtml(errorInfo.text);
                    return {
                        regex: new RegExp(escapeRegExp(escapedText), 'gi'),
                        info: errorInfo
                    };
                });

                // Track all matches with their positions
                const allMatches = [];

                patterns.forEach(pattern => {
                    let match;
                    const regex = new RegExp(pattern.regex);

                    while ((match = regex.exec(displayHtml)) !== null) {
                        allMatches.push({
                            start: match.index,
                            end: match.index + match[0].length,
                            text: match[0],
                            info: pattern.info
                        });

                        // Prevent infinite loop
                        if (allMatches.length > 200) break;
                    }
                });

                // Sort by position (reverse order for replacement)
                allMatches.sort((a, b) => b.start - a.start);

                // Remove overlapping matches
                const filteredMatches = [];
                let lastEnd = Infinity;

                for (const match of allMatches) {
                    if (match.end <= lastEnd) {
                        filteredMatches.push(match);
                        lastEnd = match.start;
                    }
                }

                // Apply highlights from end to start
                filteredMatches.forEach(match => {
                    const before = displayHtml.substring(0, match.start);
                    const after = displayHtml.substring(match.end);

                    const highlightSpan = `<span class="code-error-highlight ${match.info.type}" data-error-index="${match.info.index}" data-error="${escapeAttribute(match.info.error)}" data-fixes="${escapeAttribute(match.info.fixes)}" data-type="${match.info.type}">${match.text}</span>`;

                    displayHtml = before + highlightSpan + after;
                });
            }

            // Set the HTML content
            codeDisplay.innerHTML = displayHtml;

            // Attach hover listeners to highlighted errors
            requestAnimationFrame(() => {
                attachCodeErrorHovers();
            });
        }

        function extractTextFromLocation(location, html) {
            if (!location || typeof location !== 'string') return null;

            // Try to extract text from various location formats
            // Look for quoted text (most reliable)
            const quotedMatch = location.match(/"([^"]{3,80})"/);
            if (quotedMatch) {
                return quotedMatch[1];
            }

            // Look for text in single quotes
            const singleQuoteMatch = location.match(/'([^']{3,80})'/);
            if (singleQuoteMatch) {
                return singleQuoteMatch[1];
            }

            // Look for code snippets in backticks
            const backtickMatch = location.match(/`([^`]{3,80})`/);
            if (backtickMatch) {
                return backtickMatch[1];
            }

            // Look for text after "text:" or similar
            const textMatch = location.match(/text:\s*([^\n,]{3,80})/i);
            if (textMatch) {
                return textMatch[1].trim();
            }

            // Try to find any meaningful text (at least 3 chars, max 80 chars)
            const words = location.split(/\s+/).filter(w => w.length >= 3 && w.length <= 80);
            for (const word of words.slice(0, 5)) { // Only check first 5 words
                const cleanWord = word.replace(/[^a-zA-Z0-9\s]/g, '');
                if (cleanWord.length >= 3 && html.includes(cleanWord)) {
                    return cleanWord;
                }
            }

            return null;
        }

        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\    @media (max');
        }

        function attachCodeErrorHovers() {
            const highlights = document.querySelectorAll('.code-error-highlight');
            let currentTooltip = null;
            let tooltipTimeout = null;
            let isHoveringTooltip = false;
            let isHoveringHighlight = false;

            highlights.forEach(highlight => {
                highlight.addEventListener('mouseenter', function (e) {
                    isHoveringHighlight = true;

                    // Clear any existing timeout
                    if (tooltipTimeout) {
                        clearTimeout(tooltipTimeout);
                        tooltipTimeout = null;
                    }

                    const errorText = this.dataset.error || 'No error description available';
                    const fixesText = this.dataset.fixes || '';
                    const type = this.dataset.type || 'content';

                    // Populate tooltip
                    errorTooltip.querySelector('.tooltip-type').textContent = type.toUpperCase();
                    errorTooltip.querySelector('.tooltip-error').textContent = errorText;

                    // Format fixes for tooltip
                    const fixContent = errorTooltip.querySelector('.tooltip-fix-content');
                    if (fixesText) {
                        fixContent.innerHTML = formatFixesForTooltip(fixesText);
                    } else {
                        fixContent.innerHTML = '<em>No fixes suggested</em>';
                    }

                    // Position tooltip with improved logic
                    const rect = this.getBoundingClientRect();
                    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;

                    // Calculate initial position (below the highlight)
                    let top = rect.bottom + scrollTop + 15;
                    let left = rect.left + scrollLeft;

                    // Show tooltip first to get its dimensions
                    errorTooltip.style.visibility = 'hidden';
                    errorTooltip.style.display = 'block';

                    const tooltipRect = errorTooltip.getBoundingClientRect();
                    const tooltipWidth = tooltipRect.width;
                    const tooltipHeight = tooltipRect.height;

                    // Adjust horizontal position if tooltip goes off screen
                    if (left + tooltipWidth > window.innerWidth + scrollLeft) {
                        left = window.innerWidth + scrollLeft - tooltipWidth - 20;
                    }
                    if (left < scrollLeft + 10) {
                        left = scrollLeft + 10;
                    }

                    // Adjust vertical position if tooltip goes off bottom of screen
                    if (top + tooltipHeight > window.innerHeight + scrollTop) {
                        // Position above the highlight instead
                        top = rect.top + scrollTop - tooltipHeight - 15;
                    }

                    // Ensure tooltip doesn't go above viewport
                    if (top < scrollTop + 10) {
                        top = scrollTop + 10;
                    }

                    errorTooltip.style.top = top + 'px';
                    errorTooltip.style.left = left + 'px';
                    errorTooltip.style.visibility = 'visible';
                    errorTooltip.classList.add('show');

                    currentTooltip = errorTooltip;
                });

                highlight.addEventListener('mouseleave', function (e) {
                    isHoveringHighlight = false;

                    // Start timeout to hide tooltip
                    tooltipTimeout = setTimeout(() => {
                        if (!isHoveringTooltip && !isHoveringHighlight) {
                            errorTooltip.classList.remove('show');
                            errorTooltip.style.display = 'none';
                            currentTooltip = null;
                        }
                    }, 150);
                });

                // Click to scroll to error card
                highlight.addEventListener('click', function (e) {
                    e.preventDefault();
                    e.stopPropagation();

                    const errorIndex = this.dataset.errorIndex;
                    const errorCards = document.querySelectorAll('.error-card');

                    // Find the matching error card
                    let targetCard = null;
                    errorCards.forEach(card => {
                        if (card.dataset.errorIndex === errorIndex) {
                            targetCard = card;
                        }
                    });

                    if (targetCard) {
                        // Hide tooltip immediately
                        errorTooltip.classList.remove('show');
                        errorTooltip.style.display = 'none';
                        isHoveringHighlight = false;
                        isHoveringTooltip = false;

                        // Scroll to card
                        targetCard.scrollIntoView({ behavior: 'smooth', block: 'center' });

                        // Highlight effect
                        targetCard.style.transition = 'all 0.3s ease';
                        targetCard.style.outline = '3px solid var(--primary-color)';
                        targetCard.style.transform = 'scale(1.02)';

                        setTimeout(() => {
                            targetCard.style.outline = '';
                            targetCard.style.transform = '';
                        }, 2000);
                    }
                });
            });

            // Allow hovering over tooltip without it disappearing
            errorTooltip.addEventListener('mouseenter', function () {
                isHoveringTooltip = true;

                // Clear any existing timeout
                if (tooltipTimeout) {
                    clearTimeout(tooltipTimeout);
                    tooltipTimeout = null;
                }
            });

            errorTooltip.addEventListener('mouseleave', function () {
                isHoveringTooltip = false;

                // Start timeout to hide tooltip
                tooltipTimeout = setTimeout(() => {
                    if (!isHoveringTooltip && !isHoveringHighlight) {
                        errorTooltip.classList.remove('show');
                        errorTooltip.style.display = 'none';
                        currentTooltip = null;
                    }
                }, 150);
            });
        }

        function formatFixesForTooltip(fixesText) {
            if (!fixesText) return '<em>No fixes suggested</em>';

            const lines = fixesText.split('\n').map(line => line.trim()).filter(line => line);
            let result = '';

            lines.forEach(line => {
                if (line.startsWith('*') || line.startsWith('-')) {
                    const content = line.substring(1).trim();
                    result += `<div class="fix-option">${escapeHtml(content)}</div>`;
                } else if (/^\d+\.\s+/.test(line)) {
                    const content = line.replace(/^\d+\.\s+/, '');
                    result += `<div class="fix-option">${escapeHtml(content)}</div>`;
                } else if (line.length > 0) {
                    result += `<div style="margin-bottom: 4px;">${escapeHtml(line)}</div>`;
                }
            });

            return result || '<em>No fixes suggested</em>';
        }

        // Hide tooltip when clicking outside or scrolling
        document.addEventListener('click', function (e) {
            if (!e.target.closest('.code-error-highlight') && !e.target.closest('.error-tooltip')) {
                errorTooltip.classList.remove('show');
                errorTooltip.style.display = 'none';
            }
        });

        document.getElementById('code-content').addEventListener('scroll', function () {
            errorTooltip.classList.remove('show');
            errorTooltip.style.display = 'none';
        });

        function getErrorSummary(errorText) {
            if (!errorText) return '';

            const sentences = errorText.split('.');
            if (sentences.length > 0) {
                return sentences[0].trim() + (sentences[0].endsWith('.') ? '' : '.');
            }
            return errorText.substring(0, 80) + (errorText.length > 80 ? '...' : '');
        }

        function formatLocationText(locationText) {
            if (!locationText) return '';

            let cleanedText = locationText.trim();
            const lines = cleanedText.split('\n').map(line => line.trim()).filter(line => line);

            return lines.map(line => {
                if (line.startsWith('*') || line.startsWith('-')) {
                    const content = line.substring(1).trim();
                    if (content.includes('`')) {
                        return `<div class="location-item"><div class="code-block">${escapeHtml(content.replace(/`/g, ''))}</div></div>`;
                    } else {
                        return `<div class="location-item">${escapeHtml(content)}</div>`;
                    }
                } else if (line.includes('`')) {
                    return `<div class="code-block">${escapeHtml(line.replace(/`/g, ''))}</div>`;
                } else {
                    return `<div>${escapeHtml(line)}</div>`;
                }
            }).join('');
        }

        function formatFixes(fixesText) {
            if (!fixesText) return 'No fixes suggested';

            const lines = fixesText.split('\n').map(line => line.trim()).filter(line => line);
            let result = '';

            lines.forEach(line => {
                if (line.startsWith('*') || line.startsWith('-')) {
                    const content = line.substring(1).trim();
                    result += `<div class="fix-option">${escapeHtml(content)}</div>`;
                } else if (/^\d+\.\s+/.test(line)) {
                    const content = line.replace(/^\d+\.\s+/, '');
                    result += `<div class="fix-option">${escapeHtml(content)}</div>`;
                } else if (line.includes('```') || line.trim().startsWith('<') || line.includes('Example:')) {
                    result += `<div style="margin-top: 8px; font-style: italic;">${escapeHtml(line)}</div>`;
                } else {
                    result += `<div>${escapeHtml(line)}</div>`;
                }
            });

            return result;
        }

        function filterErrors(category) {
            const errorCards = document.querySelectorAll('.error-card');

            errorCards.forEach(card => {
                if (category === 'all' || card.dataset.category === category) {
                    card.style.display = 'block';
                } else {
                    card.style.display = 'none';
                }
            });
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function escapeAttribute(text) {
            if (!text) return '';
            return String(text)
                .replace(/&/g, '&amp;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
        }

        function showError(message) {
            errorText.textContent = message;
            errorMessage.style.display = 'block';
            loading.style.display = 'none';
            submitBtn.disabled = false;
        }

        // Initialize
        urlInput.value = '';
        attachMetricInteractions();
        attachErrorDropdowns();

    });


</script>
{% endblock %}
